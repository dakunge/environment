内聚性
1.功能内聚性: 最强，最好的内聚性
2.顺序内聚性: 围绕同一份数据做不同的事，通过修改函数名，从新划分，可以转变为功能内聚性
3.通讯内聚性: 做多件事情，只是数据采用的是同一份
4.临时内聚性: 因为同时执行的原因，将代码放在一起

不可取的内聚性
1.过程内聚性: 与顺序内聚性不同的地方在与围绕不同数据进行操作
2.逻辑内聚性: 参数还有 flag，如果函数只有 if flag else 和 其他子程序调用时 是可以接受的，称为事物处理中心
3.偶然内聚性: 无任何联系，也就是无内聚性

耦合标准
1.耦合规模: 互相之间传递的参数越少越好
2.密切性: 参数最直接，全局变量稍低，共享文件，数据库最低。越密切越好.
3.可见性: 参数最可见，全局变量较差（带上注释好一些），越可见越好，越隐蔽，越容易犯错，特别是修改程序的时候
4.灵活性: 越容易被其他子程序调用越灵活

耦合层次
1.简单数据耦合: 参数是基本类型，最好的耦合
2.数据结构耦合: 参数是数据结构，也比较好
3.控制耦合: 被调用者根据调用者传递参数不同，做不同的事，不好的耦合，引起了逻辑内聚性
4.全局数据耦合: 不好的耦合，如果都是只读的还可以忍受

1.结构化设计: 适合功能性改变较多,规模较小的程序，超大规模的程序，无能无力
2.面向对象: 适合数据变化较大

变量命名
1.长度8-20
2.作用域较小的可使用短命名
3.变量越有意义的部分应该越靠前，命名原则一直（极大提高愉悦感）
4.count 表示总数，index表示下表
5.反义词

add/remove,      begin/end,         create/destroy
insert/delete,     first/last,            get/release
increment/decrement put/get,    up/down
lock/unlock         min/max,           next/previous
old/new               open/close,       show/hide
source/destination source/target  start/stop

6.循环变量命名: 简单i,j,k, 循环体较长，逻辑较复杂用有意义的名字
7.tmp 这种变量最好别用
8.逻辑变量: 好的,success, done, found, 不好的 status(什么信息也表示不了), 不用 notFound 这种
9.遵守命名约定: 全局变量g_, 模块变量m_, 类型定义_t, 常量_C, 枚举_e, 输入参数 const ,* 等

变量作用域
1.尽量减小变量作用域

全局变量
1.引起代码混乱(当做参数传递)，代码重入
2.有利用写，容易修改，不利于读，消除穿梭数据
降低全局变量副作用
1.能不用则不用，除非迫不得已
2.区分全局和模块变量
3.使用命名约定，使其明显 g_
4.增加全局变量注释
5.需要加锁时要加锁
6.使用存取子程序

存取子程序优点
1.可以对子程序进行集中控制
2.自动获得信息隐蔽带来的好处
3.容易转换为抽象类型

应该就是封装的好处，全局变量用存取子程序是好的，所有的变量都用存取子程序感觉是不好的，因为
都要跳进去看，读代码的时候一般都是数据结构记的比较清楚，直接赋值感觉更易读
